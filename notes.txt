Notes:

~ JSX is not a HTML inside javascript, JSX is a html like syntax, but not exactly html
~ for multiple elements react uses a key to uniquely identify each element "key is not a id in html"
~ working : React.createElement(tag) => object => HTML (DOM) (babel comverts this JSX into react object which is then rendered in HTML DOM)
~ JSX uses camelcasing similar to Js
~ Name of a component starts with Capital Letter (not mandatory but a good practice), the react element can be smaller case
~ we can write javascript expressions inside { } braces , but not js statements.
~ Never write useState hook inside if/else/for statements
~ Write useState inside the functional component which it belongs to. as useState creates the local variable for the component.

~ Q : Why do we use super(props) in constructor?
	A : super(props) is used to inherit the properties and access of variables of the React parent class when we initialize our component. super() is used inside constructor of a class to derive the parent's all properties inside the class that extended it. If super() is not used, then Reference Error : Must call super constructor in derived classes before accessing 'this' or returning from derived constructor is thrown in the console. The main difference between super() and super(props) is the this.props is undefined in child's constructor in super() but this.props contains the passed props if super(props) is used.


~ Few Things about JSX

	- A jsx code can only have one parent
		eg : const title = ()=>{
				<h2>HEllo</h2>  //this is incorrent
				<h3>masdkds</h3>
			}
	- to use multiple element we should wrap it inside a <div> or <React.Fragment> or simply use empty tags (<> </>)(shorthand of react.fragment) to wrap the elements inside
		const title = ()=>{
			<React.Fragment> //now its valid
				<h2>Hello</h2>  
				<h3>masdkds</h3>
			</React.Fragment>
		}

	- To give a style to a jsx element, we use style = {}, and define attributes inside {} , style takes object as argument in Js
		<div style={{backgroundColor:"red"}}></div>
			or 
		const styleobj = {background-color:"red"}
		<div style={styleobj}></div>

~ Something about props

	- props are the properties(parameters) passed to a react component(as an argument). 
		Suppose this API is given:
		 const restList = [
    		data: {
      			id: "1",
      			name: "KFC",
      			area: "Koramangala",
  			},]
	
		eg. const reactobj = (props)=>{ //its not mandatory to use props word, we can name it anything, but genrally we name it props 
				<h2>{props.name}</h2>;
			}
			<reactobj name="Harshit" />		//here name prop is passed as object to the component

	- suppose there are multiple properties that are to be passed, then it is good to destructure the prop object inside the react component
		const reactobj = (props)=>{  
			const {name,id,area} = props.restraunt.data; //when we destructure the object
			<h2>{name}</h2>;		//then we dont need to write the props anymore
			<h2>{id}</h2>;
			<h2>{area}</h2>;
		}
		<reactobj restraunt={restList[0]} />

	- one more way to direct destructure the object
		const reactobj = ({restaurant})=>{  //we destructured the object directly inside the function
			const {name,id,area} = restraunt.data; //then we dont need to write the props anymore 
			<h2>{name}</h2>;
			<h2>{id}</h2>;
			<h2>{area}</h2>;		
		}
		<reactobj restraunt={restList[0]} />

	- another way of destructuring object directly inside react component
		const reactobj = ({name,id,area})=>{  //note: here order of items is important, as destructuring is done directly in fn header
			<h2>{name}</h2>;
			<h2>{id}</h2>;
			<h2>{area}</h2>;		
		}
		<reactobj name={restList[0].data.name} id={restList[0].data.id} area={restList[0].data.area} /> //now we have to pass the props one by one
					or
	 		instead of passing each and every props we can use javascript ES6 using spread operator for passing multiple props
		<reactobj {...restList[0].data} /> 


~ Something about Imports and  Exports:
	- we can export the components by 2 ways,
		1. default export (we can export only one component by default)
		2. named export  (can export as much we want)

	- if we default export a component then we can import it directly into the app without using {}
			>>  export default ComponentOne;
		   	<<  import ComponentOne from "src/ComponentOne";
	- in default export, while importing a component , the name doesnt matter , we can rename it (not allowed in named export)
			>>  export default ComponentOne;
		   	<<  import myRenamedComponent from "src/ComponentOne"; //we renamed ComponentOne to myRenamedComponent
	- to export multiple components as default we had to export them by making an array or Something
			>> export default {Title,Heading};
		   	>> import obj from "src/Component";
		    {<obj.Title />,<obj.Heading/>};

	- if we named export a component directly then we had to use the {} braces(mandatory)
			>> export const Title () =>{}
			>> import {Title} from "src/Title;

	- if we had to import multiple named Exports then
			>> export {Title,Header};
			<< import * as obj from "src/Header"; //here we cannot write like "import obj from "src/header"" because its not like default export
						or						  // we have to use {} braces while named importing
			<< import {Title,Header} from "src/Header"; 
	
	- we can export both named and default export at the same time
			>> export default Header;
			>> export const Title = ()=>{}
			<<link import Header,{Title} from "src/Header";  //named import using {}, default import directly

~ Something about React Hooks and useState Hook

	- React Hooks are the simple functions that have their own unique functionality.
	- useState Hook is a fn which is used to create state variables, it returns an array which contains [name of variable, fn to modify that variable]
	- useState Hook syntax
		const [variableName, setVariableFunctionName] = useState("default value");		//same like: const variableName = "default value";
	- here setVariableFunctionName is used to set the value of a state variable. 
	 eg. 	const searchText = useState();
	    	const [searchText,setSearchText] = useState(); // so we destructure the useState Hook
	 or		const searchText = useState(); 	
	 		[searchText,setSearchText] = searchText; 
	- import using named variable ; import {useState} from "react";
	- in react, we cannot directly assign the value of a state variable, we have to use the setState function which we already defined in useState
		setVariableFunctionName("new value"); 			// same like: variableName = new value 

~ Somethings about useEffect Hooks

	- useEffect Hook is a function which is placed inside any component , it will call itself each time when the component is re rendered.
	- It has a callback function as it’s 1st parameter, and a dependency array as its 2nd parameter.
	- Callback fn is called each time useState() is called. because useState(), when defined within a component, is called everytime our component is re-rendered.
 	- We know that our component is re-rendered whenever, we load a page or a state variable changes or we change the props. But, this is a bad way to call it.
	- To call the useEffect hook on specific time, we use the dependency array, which is passed in useEffect hook as 2nd argument.
	- This array accepts any variable. Those variables are treated as dependencies and only when any of those variables are changed, the useEffect hook is called (except the first time when useEffect is called when the page is loaded). 
	- If we keep the dependency array empty, then useEffect will only be called once, at loading the page. 
	- syntax
		useEffect(()=>{/* callback() fn */}, [dependency array]);
	- Its used when we want to execute some function at a certain time, (like when a certain component renders,then execute a function).
	- useEffect hook also have the cleanup function that invokes when the component goes out of scope i.e when we move to another page, so its kind of similar to componentWillUnmount() of CBC, its written as:
		useEffect(()=>{
			return()=>{}; //inside return() we can define the contents which we want to cleanup before moving to another page
		},[])


~ React Router DOM
	- Install it using npm i react-router-dom
	- import {createBrowserRouter,RouterProvider} from "react-router-dom";
	- const appRouter = createBrowserRouter([{
		/* define path */
	   }]);
	   eg. const appRouter = createBrowserRouter([
		{path:"/", element:<AppLayout/>},{path:"/About",element:<AboutUs/>}])
	- Now we render the root according to our router path
	  root.render(<RouterProvider router={appRouter}/>);
	- To build single page application, we need to fix the links in header and replace anchor tags with the link to tag.
		but first import {Link} from 'react-router-dom';
		<a href="/"></a> => <Link to="/"></Link>
	- Two types of routing 
		1. client side routing (used in React)
		2. server side routing
	- To find the errors while routing pages, use the useRouterError hook from the react router dom 	
		import {useRouterError} from "react-router-dom";
		const err = useRouterError(); //this object will give us all details about the error  like error code or status
	- A custom error page can also be created, and inside the createBrowserRouter(), we declare it as, errorElement :  <Error Component />;
	- Nested Routing - to route to the specific child component, inside the parent component, we use nested routing
		like <header />
				<about />  //here about is the child component, if we want to route to it, we use something like <Outlet /> 
			<footer />> 		//THe Outlet will be filled by the children config while rendering the parent components
		first import {Outlet} from "react-router-dom"; 
		then place the outlet inside the Applayout component where all the other components are defined.
		then make children components in the createBrowserRouter(), like children :[{path:"/about",element:<About/>}], where object is the path of child component.
	- useParams Hook:- react-router-dom provides us useParams Hook. This function returns the parameter in out path.
		const outPath = useParams(); //if we console log it, we get the different parameters from react-router-dom which are hidden in our path
	
~ React Class Based components
	-You cannot create a class-based component without a render() method. a class-based component (CBC) returns JSX using the render().
	syntax:
		class CLASSNAME extends React.Component {
			render(){
				return ();
			}
		} export default CLASSNAME;
	- Props are passed to component(<cbc name="CBC"/>) as usual but used inside the component by using this.props.propName.
	- We know that classes have a constructor which is a special member function used for initialisation and hence we create the state variables inside a class constructor. 
	- We use this.state object(to create local state variables) In that object we can write the state variables with their initial value in the form of key-value pairs.
	- In CBC, the state variables are created inside a single state object inside the constructor
	constructor(props){
		super(props);
		this.state = {count:0,count1:1};
	}
	- To update the state variables we use setState() method
		this.setState({count:0, count2:1});
	- Class based components uses a Life cycle methods
		A constructor is called before the render method 
		A componentDidMount() method (like useEffect hook) is called after render. (Great place to call an API)
	-	 Following is the order of lifecycle methods calls in Class Based Components:
		constructor()
		render ()
		componentDidMount()
		componentDidUpdate()
		componentWillUnmount()
	- ComponentDidUpdate() is called when the rerendering of an existing component and its updation in DOM has already been done. In simple words,  this method will be called after every next render.
	-componentWillUnmount() is useful for the cleanup of the application when we switch routes from one place to another. Since we are working with a SPA(Single Page Application) the component process always runs in the background even if we switch to another route. So it is required to stop those processes before leaving the page.

~ Custom Hooks
	- We can build our own hooks to ensure readability, reusability, maintainability / modularity ,testable : because I can write separate test cases for each helper function/hook.
	- Always, mention “use” as the prefix of the filename containing our hook.
	- Always do a named export from the hooks file because a default export fails to imply which function that file is exporting.
	- a custom hook file can contain more than one hook, then we should have to export diffrent hooks thru named export  like export {hook1, hook2}.
	- first import the custom hook file then use it like
		>>	import {useRestraunt} from "utils/useRestraunt";
		>>	const restaurant = useRestraunt();
	
~ Lazy loading
	- Also known as Chunking / Code-splitting / Dynamic Bundling / Lazy Loading / On-demand Loading / Dynamic Import
	- In single page applications, like a react app, the parcel bundles(also does compression) the app into one file. For an SPA app, the file could become very large and thus take longer time to load, thats why we can split up the app into multiple components and by using lazy loading we can load the specific components at the specific time.
	- for eg - a <About /> component should be loaded only when we click the link to about page, for this , the lazy load creates a new network call to grab the <About /> component file used for loading it. This way we ensures the network load is optimal.
	- When we build a large scale application, then there will be multiple components and bundling them all up in a single js file will take much time to load. Therefore, we should break the entire production ready code into smaller parts. This concept is called Chunking/Code-splitting.
	- working
	suppose we have a component <About/> which we want to lazy loaded
	- we have to use a lazy(){named import from react library} fn while importing the <About/>, and we have to pass a callback function to it.
		>>  const about = lazy(()=>import("./components/about));
	- we have to tell React to stop rendering a component until the bundle with that specific component gets loaded. To do this, we just wrap around that component with a element named <Suspense>
		>> import { lazy,Suspense } from "react";
		>> <Suspense>
				<About />
		   </Suspense>
	- Never dynamically import one component inside another component. This is because if we do so, the former component will get dynamically imported in every render cycle of the latter component

~ createContext and useContext Hooks
	- we should rather store the details (which we need throughout our code) in a central storage space. Storing the details in local storage is not a good idea because updating from local storage is a time consuming operation. As such, React gives us a central storage to store these values, called Context. 
	- React provides a hook called createContext. It takes in the default value of our context and helps to make our data available throughout our app
		<< create a [UserContext.js] Hook file to store these context values. 
		>> import {useContext} from "react"
		>> const UserContext = useContext({ //default object values});
	- Now, we have successfully created an user data which we can globally use and exported it. We have to now access this data from the necessary components. To use the context, React provides us another hook called useContext.
		>> import {useContext} from "react"
		>> import UserContext from "../utils/UserContext";
		>> const {user} = useContext(UserContext); //destructured the values obtained from the user context
	- Using useContext() in a Class Based Component :-
	We know that in CBC, we do not have any concept of hook. So, in CBC we first import the context that was created (here UserContext) and use it as a component. This component can accept a JSX piece of code, within which we can write a function where the function parameter is actually the context data.

~ React Redux
	>>	npm i @reduxjs/toolkit
	>>	npm i react-redux
	-create a store file for 
	>>	import { configureStore } from "@reduxjs/toolkit";
	>>	const reduxStore = configureStore({});
	>>	export default reduxStore;
	- we can provide this store to whole app or a specific component
		for eg, if using in whole app, then , in app.Js
	>>	import {Provider} from "react-redux";
	>> 	import {reduxStore} from "./utils/reduxStore";
	- we have to wrap up the whole body components in <Provider>
	>> 	<Provider store={reduxStore}> <body /> </Provider>
	- creating slices for store in new file, where we define the structure of slice [name, items, reducer, ...]
	>> 	const cartSlice = createSlice({name: ABC, initialState: {items:[...], ... }, reducers: {fn_definitions(),... }});
	now we can use cartSlice in our store as:
	>> 	import { createSlice } from "@reduxjs/toolkit";	
	>>	const reduxStore = configureStore({reducer: { cart: cartSlice,}, ... });
	- To store the states of components , we have to first import useDispatch and reducer functions of required slice.
	>>  import { useDispatch } from "react-redux";
	>> 	import {addItems,removeItems} from "../utils/slice";
	